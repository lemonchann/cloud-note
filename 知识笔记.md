[TOC]
#### 

### C和C++

- [C++前置声明](https://juejin.im/post/5d5011345188255b0743fb7d) 

  相互包含引用头文件，**配合指针使用**

- [结构体赋值的4种方法](https://blog.csdn.net/ericbar/article/details/79567108)
- [stl容器比较vector list queue deque](https://www.jb51.net/article/41590.htm)
- [stl容器比较2](https://blog.csdn.net/a731062834/article/details/82975776)
- [c++继承层次的hide和override](https://www.cnblogs.com/xinxue/p/5471708.html)
- 宏高级用法 #和##和__VA_ARGS__和##__VA_ARGS__
> [ref1](https://blog.csdn.net/u011068702/article/details/93364615)  [ref2](https://blog.csdn.net/blackbillow/article/details/3850587)
> #把宏参数变为一个字符串,用##把两个宏参数贴合在一起. 这里的__VA_ARGS__，是指打印宏里面的可变参数，也就是函数参数里面的...  ##__VA_ARGS__ 可变参数只有一个也能传递
- 前置声明的真正用法：
1. 在头文件里不引入过多的其他头文件和名称空间，避免污染
2. 在相应的c文件里面再引入其他头文件
3. 同时，必须把头文件放在需要引用的其他头文件之后才行
4. 因为，编译都是从c文件开始，头文件只是包含展开而已。
- 隐藏与重写
>- hide隐藏作用于子类和基类都有同一个非虚函数的继承，子类的函数会把基类的隐藏掉;
> - override重写作用于非纯虚函数的继承层次，子类重写基类的虚函数实现。

---
### python

#### 每日一库

1. OptionParser  2.7后弃用，命令行参数解析

   ```
   parser = optparse.OptionParser()
   parser.add_option('-d', '--database', default='db_test', help='working database')
   options, args = parser.parse_args(argv)
   execute_sql(tdw, 'use ' + options.database)
   if options.build:
   build_table(tdw, options.table)
   for date in calculate_date_range(args):
   ```

2. datetime 时间转换

   ```
   date = (datetime.datetime.strptime(date, '%Y%m%d')).strftime('%Y%m%d')
   next_date = (datetime.datetime.strptime(date, '%Y%m%d') + datetime.timedelta(days=1)).strftime('%Y%m%d')
   ```

   



- [pycharm常用快捷键](https://www.cnblogs.com/insane-Mr-Li/p/9698994.html)

- [为什么不推荐Selenium写爬虫](https://zhuanlan.zhihu.com/p/33542626)

- [理解Python协程:从yield/send到yield from再到async/await](https://blog.csdn.net/soonfly/article/details/78361819)

- 获取帮助help(str.join)  help(list.) help(dict.) help(tuple.)

- [语法糖](https://blog.csdn.net/wofreeo/article/details/80679290)
[Python语法糖系列](https://blog.csdn.net/five3/article/details/83474633)
- [Python爬虫之requests库(二)：响应内容、响应状态码、响应头](https://blog.csdn.net/bqw18744018044/article/details/81171220)
- [Pybind11调用c++](https://zhuanlan.zhihu.com/p/63290768)
- [Python 入门指南](http://www.pythondoc.com/pythontutorial3/modules.html)
- [官方Python 3.7.3 documentation-在程序安装目录的Doc下](https://docs.python.org/3/)
- [pycharm教程](https://www.cnblogs.com/tsingke/p/7392800.html)
- [pycharm破解方法](https://blog.csdn.net/qq_41235053/article/details/81390453)
- [pycharm破解码生成网站](http://idea.lanyus.com/)

> 56ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==
- [py2中的raw_input，input 与 py3中的input](https://blog.csdn.net/qq_39480314/article/details/80092051)
- 进阶：effective python
- [diveinto python中文版官网](https://woodpecker.org.cn/diveintopython/toc/index.html)
- [生成器VS迭代器1](http://python.jobbole.com/87805/)
- [生成器VS迭代器2](https://www.cnblogs.com/wj-1314/p/8490822.html)
- [notepad++支持markdown](https://www.jianshu.com/p/cdb42773fffe)

- [字符编码方式](https://baike.baidu.com/item/Unicode)
> **Unicode**   
> Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案,Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布  
> **UTF-8**  
> *Unicode Transformation Format*的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据
> UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：

| Unicode编码(十六进制) | UTF-8 字节流(二进制)             |
| --------------------- | -------------------------------- |
| 000000-00007F         | 0xxxxxxx                         |
| 000080-0007FF         | 110xxxxx 10xxxxxx                |
| 000800-00FFFF         | 1110xxxx 10xxxxxx 10xxxxxx       |
| 010000-10FFFF         | 11110xxx10xxxxxx10xxxxxx10xxxxxx |

>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。
>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。
>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。

- 数据库读取  records库

---
### C++11
- g++ -std=c++11 编译选项
- [C++11常用特性快速一览](https://blog.csdn.net/jiange_zh/article/details/79356417)
- [C和C++中的左值和右值](https://blog.csdn.net/xuwqiang1994/article/details/79924310)
- [30分钟了解C++11新特性](https://www.cnblogs.com/mengfanrong/p/5230558.html)
- [GCC4.8 支持C++11](https://www.cnblogs.com/jhj117/p/6117204.html)
---
### shell
- [shell获取字符串长度](https://www.jb51.net/article/121290.htm)
- [Shell $?：获取函数返回值或者上一个命令的退出状态](http://c.biancheng.net/view/808.html)
> 1. 命令的退出状态0-正常；非0-不正常
> 2. 获取函数的返回值
---
### 虚拟机
- [centos桌面版安装](https://blog.csdn.net/alan_gaohaodong/article/details/79867052)
- [Virtualbox扩展虚拟磁盘空间大小](https://blog.csdn.net/tanningzhong/article/details/80482994)

---
### Linux

- find命令

  ```
  find ./ -maxdepth 1 -mindepth 1 -type d  -mtime +30 |xargs rm -fr
  添加用户带密码和home路径:
  useradd lemon -d /data/lemon -p 123456
  ```

- [认真分析mmap：是什么 为什么 怎么用](https://www.cnblogs.com/huxiao-tee/p/4660352.html) 

- [win查看MD5 SHA](https://blog.csdn.net/p358278505/article/details/70672169)

- makefile语法学习

- 时间转换命令

  ```
  [root@365linux ~]# date +%s 
  [root@365linux ~]# date -d "@1279592730" 
  [root@365linux ~]# date -d '06/12/2018 07:21:22' +"%s"
  1528759282
  [root@365linux ~]# date -d '2018-06-12 07:21:22' +"%s"
  1528759282
  ```
  
- linux[时间函数](https://juejin.im/post/5be682706fb9a049ef261855)

   编译时要在编译命令最后加上-lrt链接Real Time动态库，如 g++ -o time2 test_time_linux_2.cpp -lrt 

- linux data[命令获取上一天时间](https://blog.csdn.net/classhao1/article/details/8182733)

   获取明天的日期

   date -d next-day +%Y%m%d

   获取昨天的日期

   date -d last-day +%Y%m%d

   获取上个月的年和月

   date -d last-month +%Y%m

   获取下个月的年和月
   date -d next-month +%Y%m

   获取明年的年份
   date -d next-year +%Y

- [crontab在线测试](https://tool.lu/crontab)

- 非常好用的Linux调试命令

   [strace](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)

    strace常用来跟踪进程执行时的系统调用和所接收的信号。还可以统计时间开销

     [pstack](https://www.cnblogs.com/kongzhongqijing/articles/7685699.html) 

    `pstack`是一个shell脚本，用于打印正在运行的进程的栈跟踪信息，它实际上是`gstack`的一个链接，而gstack本身是   基于gdb封装的shell脚本.。  `pstack`是gdb的一部分 

   

---
### 算法
- [斐波那契实现C版本](https://blog.csdn.net/weixin_40740059/article/details/80012909)

- [快速求幂算法](https://blog.csdn.net/hkdgjqr/article/details/5381028)

- [牛客题目](https://www.nowcoder.com/questionTerminal/1a834e5e3e1a4b7ba251417554e07c00)

- [base64](https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576)

  > Base64是一种用64个字符来表示任意二进制数据的方法。Base64的原理很简单，首先，准备一个包含64个字符的数组：
  >
  > ```
  > ['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
  > ```
  >
  > 然后，对二进制数据进行处理，每3个字节一组，一共是`3x8=24`bit，划为4组，每组正好6个bit：
  >
  > ![base64-encode](https://www.liaoxuefeng.com/files/attachments/949444125467040)
  >
  > 这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。
---
### 工具生产力

- utools alt+space唤起

  包含python doc、linux doc、时间转换、本地查找等快捷方式

- [vscode插件推荐](https://blog.fundebug.com/2018/07/24/vs-extensions/)
- [notepad++显示文件列表](https://jingyan.baidu.com/article/066074d61011f3c3c21cb0ce.html)
- [正则表达式\w \d](https://www.jb51.net/article/118706.htm)
- 正则常见匹配
> * . 匹配除换行符以外的任意字符  
> * \w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。   
> * \s 匹配任意的空白符
> * \d 匹配数字
> * \b 匹配单词的开始或结束
> * ^ 匹配字符串的开始
> * $ 匹配字符串的结束
> * \w能不能匹配汉字要视你的操作系统和你的应用环境而定

- [CI/CD]https://www.redhat.com/zh/topics/devops/what-is-ci-cd
> CI/CD 中的“CI”始终指持续集成, CD 持续交付和/或持续部署
- [Win10操作](https://www.zhihu.com/question/54389145/answer/143788533)   
> win+q是打开Cortana的搜索框，可以搜索应用，比如记事本，可以搜索可执行程序，比如能够在“运行“中直接使用的，如calc计算器，notepad记事本，mspaint画图，cmd是命令行  
win+x   
win+上下左右，可以调整窗口，最大化/还原，靠左/靠右贴边排列。     ctrl+win+d创建新的虚拟桌面，ctrl+win+左右用来切换桌面，ctrl+win+F4关闭虚拟桌面（win+tab的任务视图里也可以管理虚拟桌面）。
ctrl+shift+esc启动任务管理器，比ctrl+alt+delete少一步操作。
截图不需要qq。键盘上的PrtScn按键就是截图键，全屏截图到剪贴板，在绝大部分操作系统和软件下都通用。alt+PrtScn是当前窗口截图。

- [Typora md编辑器](https://sspai.com/post/54912)

- [Typora写微信公众号](https://sspai.com/post/40524)

- [Typora换公众号主题](http://support.typora.io/About-Themes/)

- [代码在线运行工具](https://tool.lu/coderunner/)

- 宇宙IDE vs2017

  [快捷键](https://www.cnblogs.com/lsgxeva/p/7944986.html)

  > F12  跳到定义; Ctrl+F12跳到声明；ctrl+-向前导航; ctrl+shift+-向后导航

  Visual Studio添加整个目录到空项目中 https://blog.csdn.net/oneinmore/article/details/43017471

  visual studio 工程目录,添加文件夹 和添加筛选器 的 https://bbs.csdn.net/topics/390838516

  visual studio技巧总结 https://blog.csdn.net/wu_nan_nan/article/details/70159267

  去掉讨厌的红色下划波浪线（ 拼写检查）https://blog.csdn.net/qq_33075489/article/details/79783142

  VS2017环境下开发Linux程序 https://blog.csdn.net/CSDN_WHB/article/details/85223652

  IDE跨平台路径： C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\Common7\IDE\VC\Linux\include\usr\local\include\google\protobuf

  添加文件类型：工具-》选项-》VC++项目设置-》要包括的扩展名

  项目属性-》常规-》配置类型-》动态库so

  一个改动，win下编译工程只会同步改动的文件过去

  跨平台编译要触发重新上传代码，一定要点重新生成。命令行的位置是生成事件-》远程链接之前事件
  
- [source insight 自动注释插件](https://my.oschina.net/u/2515635/blog/717976)

- source insight 改变编码方式

  1. 打开路径为options->Preferences->File->Default encoding. 
  2. Project->rebuild project
  3. 关掉所有打开的文件重新打卡

- csv  **Comma-Separated Values**

  > csv是最通用的一种文件格式，它可以非常容易地被导入各种PC表格及数据库中。 此文件，一行即为数据表的一行。生成数据表字段用半角逗号隔开。csv文件用记事本和excel都能打开，用记事本打开显示逗号，用excel打开，没有逗号了，逗号都用来分列了.

---
### Protocol buff
[protol buf](https://blog.csdn.net/GG_SiMiDa/article/details/81506024)
[PB中文翻译](https://colobu.com/2015/01/07/Protobuf-language-guide/#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B)
[官方指南](https://developers.google.com/protocol-buffers/docs/proto3)   
[protol buff1](https://blog.csdn.net/weixin_33686714/article/details/93640860)   
[protobuf详细](https://www.cnblogs.com/langqi250/p/7283702.html)
[protobuf extension1](https://www.cnblogs.com/mydomain/p/3177087.html)  [protobuf extension2](https://zhuanlan.zhihu.com/p/53059833)

>  extend字段是用来对原有的message类型进行扩展的。在某些场景下，可能在定义了一个基础的消息类型之后，不同的使用方需要在这个基础的消息类型上添加自己的独有字段。又或者在后续的功能升级过程中需要对该消息类型增加新的字段。这个时候预先定义了extend字段的话，就可以直接对消息进行扩展，而不用修改原来的proto文件修改消息类型的定义了。
> 一个典型的使用场景如统一的数据管理平台，不同的使用方上传的数据使用的字段是不一样的，由平台方把所有可能使用到的字段写到同一份proto文件中显然是不可能的。如记录商品信息的数据需要的字段可能是商品名、商品价格、生产日期等，而记录职员信息的数据需要的字段是姓名、年龄、职位、工龄等。此时，平台接口定义的消息类型可以只包含诸如时间、使用者等统一字段，同时预留出足够的extend字段由使用者自行定义。 

---
### 数据库

#### Mysql

- MVCC和间隙锁

  参考：

https://tech.meituan.com/2014/08/20/innodb-lock.html 

 https://juejin.im/post/5d8abc2d518825095e3d628e 

 https://juejin.im/post/5cd8283ae51d453a907b4b29 

1，Record Lock：单个行记录上的锁，行锁。

2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。

3，Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

**lemon总结：**

这种辅助索引存在间隙。

 ![img](https://user-gold-cdn.xitu.io/2019/5/12/16aac6d967b7cddf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

- 快照读 VS 当前读

  快照读-- select操作 ，利用MVCC避免不可重复读

  当前读- update、insert、delete 操作，用Next-Key Lock避免幻读

 MVCC针对的是快照读的优化，不能解决幻读问题。  

”当前读“ 存在幻读问题，只有间隙锁才能解决， 而在MySQL的RR级别中用的是Next-Key Lock， Next-Key Lock其实就是行锁+间隙锁， 当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。 



- 常用命令

 查看列：desc 表名;  

 查看表的所有信息：show create table 表名; 

修改表名：alter table t_book rename to bbb;
 添加列：alter table 表名 add column 列名 varchar(30);
 删除列：alter table 表名 drop column 列名;
 修改列名MySQL： alter table bbb change nnnnn hh int;
 修改列名SQLServer：exec sp_rename't_student.name','nn','column';
 修改列名Oracle：lter table bbb rename column nnnnn to hh int;
 修改列属性：alter table t_book modify name varchar(22);

 添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段);
 添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);
 删除主键约束：alter table 表名 drop primary key;
 删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）;



-  [select distinct 多列]( https://blog.csdn.net/bitcarmanlee/article/details/51100279 ) 

  > 2.distinct多列
  > select distinct a,b,c from tableA;
  > 注意此时是将a,b,c三列所有不同的组合全部列出来，而不仅仅只是distinct a
  > 相当于以下语句：
  >
  >  select a,b,c from tableA group by a,b,c

- mysql count及其他语法学习语法  

-  《高性能MySQL》 推荐书！！！

- MySql[官方文档](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)

- [leveldb](https://juejin.im/post/5c22e049e51d45206d12568e)

- 分库分表数据库 [分库分表](https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c)

- [各类分区](https://www.cnblogs.com/chenmh/p/5627912.html)详解

- Mysql[分表方法](http://blog.51yip.com/mysql/949.html)

  > INSERT INTO user1(user1.id,user1.name,user1.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id <= 250000
  >
  > INSERT INTO user2(user2.id,user2.name,user2.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id > 250000
  
  - [Mysql分区分表数](https://blog.csdn.net/afsvsv/article/details/84998119)
  
  > **分区的类型：**
  >
  > - RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区
  > - LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择
  > - HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式
  > - KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
  > - 具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。
  
  > **分区的限制和缺点：**
  >
  > - 一个表最多只能有1024个分区
  > - 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
  > - 分区表无法使用外键约束
  > - NULL值会使分区过滤无效
  > - 所有分区必须使用相同的存储引擎
  
  - [对已有数据的mysql表进行分区](https://blog.csdn.net/changcongying/article/details/79497004)
  
  - [查看表是否分区](https://blog.csdn.net/xiaoborui20110806/article/details/38313821)  [查看表是否有索引](https://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html) [查看容量](https://www.cnblogs.com/dekevin/p/10276832.html)
  
    > mysql> show global variables like 'port'; 查看端口
    >
    > mysql> select version(); 查看版本
  
  - [MYSQL(分表)千万级数据量的优化方法积累](https://blog.csdn.net/zhaoliang831214/article/details/52790063)
  
  > 先创建与旧表相同结构的临时表：
  >
  > CREATE TABLE members_tmp LIKE members
  >
  > 对于mysql的复制相同表结构方法，有create table as 和create table like 两种，二者的用途：
  >
  >   as用来创建相同表结构并复制源表数据
  >
  >   like用来创建完整表结构和全部索引
  >
  > 接着重命名将新表替换上去：
  >
  > RENAME TABLE members TO members_bak,members_tmp TO members;
  >
  > 旧表( `old_table_name`)必须存在，而新表( `new_table_name`)一定不存在。如果新表 `new_table_name `确实存在，该语句将失败。 
  
- [数据库索引](https://blog.csdn.net/justry_deng/article/details/81458470) [索引2](https://www.w3school.com.cn/sql/sql_create.asp) [索引3](https://blog.csdn.net/cxfjava/article/details/84869570) [主键和索引](https://blog.csdn.net/heshushun/article/details/79773957)

  > **建表后加索引：**
  >
  > ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；或
  >
  > CREATE  [UNIQUE | FULLTEXT | SPATIAL]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；
  
  > 1）主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；
  > 2）主键不允许为空值，唯一索引列允许空值；
  >
  > 3）一个表只能有一个主键，但是可以有多个唯一索引；
  > 4）主键可以被其他表引用为外键，唯一索引列不可以；
  > 5）主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别
  
- [数据库迁移](https://www.cnblogs.com/SZxiaochun/p/8359456.html)  [数据库迁移2](https://blog.csdn.net/yumushui/article/details/41647997)

  > mysqldump -u root -p123456 --all-databases > all.sql
  >
  > mysql -u root -p123456 < "D:\MySQL 5.5\bin\all.sql"

  > 对于MySQL中数据库容量比较大，而且变化比较大的数据库，采用 xtrabackup 备份后恢复构建 master-slave 的方式，然后关闭主库，启用从库的迁移保教保险和使用；
  > 但对于容量比较小，业务和变化量也比较少的mysql数据库，和Oracle数据库的export/import类型，采用mysqldump导入和导出的方式比较快捷和高效。

  [mysql bin log]( https://www.cnblogs.com/martinzhang/p/3454358.html )  [binlog详细](https://zhuanlan.zhihu.com/p/33504555)

  > ```
  > 一、开启binlog日志：
  >     vi编辑打开mysql配置文件
  >     # vi /usr/local/mysql/etc/my.cnf
  >     在[mysqld] 区块
  >     设置/添加 log-bin=mysql-bin  确认是打开状态(值 mysql-bin 是日志的基本名或前缀名)；
  > 
  >     重启mysqld服务使配置生效
  >     # pkill mysqld
  >     # /usr/local/mysql/bin/mysqld_safe --user=mysql &
  > 
  > 
  > 二、也可登录mysql服务器，通过mysql的变量配置表，查看二进制日志是否已开启 单词：variable[ˈvɛriəbəl] 变量
  > 
  >     登录服务器
  >     # /usr/local/mysql/bin/mysql -uroot -p123456
  > 
  >     mysql> show variables like 'log_%'; 
  > ```
  
  > ```
  > log-bin=mysql-bin
  > ```
  >
  > binlog 就是binary log，二进制日志文件，这个文件记录了mysql所有的dml操作。通过binlog日志我们可以做数据恢复，做主住复制和主从复制等等
  
- [Mysql分区和索引查找顺序](https://www.zhihu.com/question/21738216)

  > 在《高性能Mysql》这本书的‘如何使用分区’这一小章中，列举的常见问题中，有以下一个问题：
  >
  > **分区列和索引列不匹配**
  > 如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤。假设在列a上定义了索引，而在列b上定义的分区。因为每个分区都有其独立的索引，所以扫描列b上的索引就需要扫描每个分区内对应的索引。要避免这个问题，应该避免建立和分区列不匹配的索引，**除非查询中还同时包含了可以过滤分区的条件。**
  >
  > **where 条件中带了 A 的话，那么即是带了分区条件，这时候是会去到对应的分区，再利用 B 的索引进行查找。**
  
- [复合索引的建立以及最左前缀原则](https://blog.csdn.net/zmx729618/article/details/52701532)

  >  假设你在表的state、city和zip数据列上建立了复合索引。索引中的数据行按照state/city/zip次序排列，因此它们也会自动地按照state/city和state次序排列。这意味着，即使你在查询中只指定了state值，或者指定state和city值，MySQL也可以使用这个索引。因此，这个索引可以被用于搜索如下所示的数据列组合：
  >     state, city, zip
  >     state, city
  >     state 

- [MySQL中interactive_timeout和wait_timeout的区别](https://www.cnblogs.com/ivictor/p/5979731.html)

- Mysql[查看支持的字符集](https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html)

- Mysql 中int(11)[含义](https://cloud.tencent.com/developer/ask/36535)

  概括地说：int(N)中括号中的数字是最大的宽度，就像varchar(N)一样。

  但Integer数据类型的情况并非如此

  **括号中的数字N不是列的最大大小，而是一个参数，用于显示列的宽度**

  括号中的数字将告诉MySQL需要使用多少个零来填充传入整数。例如：如果在设置为int(5)并插入数字78的列上使用ZEROFILL参数，MySQL将使用零填充该值，直到该数字满足括号中的数字为止。也就是说，78将变成00078，127将变成00127。总之：括号中的数字用于显示。

  有些情况下，除非使用ZEROFILL属性，否则括号中的数字是没有用的。

  所以int的大小将保持不变，也就是说，**-2147483648至2147483648有符号**和**0至4294967295无符号**，就字节而言，它就是**4字节**...

- explain[查看分区](http://www.voidcn.com/article/p-ytvkfudz-eo.html)

  ```sql
  mysql> explain partitions select * from ClientActionTrack where startTime>'2016-08-25 00:00:00' and startTime<'2016-08-25 23:59:00';
  +----+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+
  | id | select_type | table             | partitions | type | possible_keys | key  | key_len | ref  | rows  | Extra       |
  +----+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+
  |  1 | SIMPLE      | ClientActionTrack | p20160825  | ALL  | NULL          | NULL | NULL    | NULL | 33868 | Using where |
  +----+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+
  1 row in set (0.00 sec)
  ```

- [查看容量](https://blog.csdn.net/fdipzone/article/details/80144166)

  select 
  table_schema as '数据库',
  table_name as '表名',
  table_rows as '记录数',
  truncate(data_length/1024/1024, 2) as '数据容量(MB)',
  truncate(index_length/1024/1024, 2) as '索引容量(MB)'
  from information_schema.tables
  where table_schema='APV4_MAIN'
  order by data_length desc, index_length desc;

---
### 后台开发

#### IPC

##### 消息队列

如果不指定 IPC_NOWAIT参数，msgsend和msgrecv都是阻塞接口，条件不符合收或发会阻塞住。 



### [RPC框架](https://mp.weixin.qq.com/s?__biz=MzI1MzYzMTI2Ng==&mid=2247484515&idx=1&sn=217dca00b2b580cbd3da7e9c51b409aa&chksm=e9d0ca2edea743380c23e16ca660e47c74cb23980f8c2379519664eee6c4fe542bdafedf4cba&mpshare=1&scene=1&srcid=0314HxrUfN45bHOyQY3j16tr&sharer_sharetime=1584191704049&sharer_shareid=c71e0673fbaa15e3038063afecc3a033#rd)

#### 常见的RPC框架和各自特点

> Dubbo 是阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现 

> Motan是新浪微博开源的一个Java 框架。它诞生的比较晚，起于2013年，2016年5月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。

> rpcx是Go语言生态圈的Dubbo， 比Dubbo更轻量实现了Dubbo的许多特性，借助于Go语言优秀的并发特性和简洁语法，可以使用较少的代码实现分布式的RPC服务。

> gRPC是Google开发的高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。 https://doc.oschina.net/grpc?t=58008 
>
> thrift是Apache的一个跨语言的高性能的服务框架，也得到了广泛的应用，Thrift是Facebook于2007年开发的，它提供多语言的编译功能，通过Thrift的IDL来描述接口函数及数据类型，通过Thrift的编译环境生成各种语言类型的接口文件。

> brpc(baidu-rpc)是百度开发一款远过程调用网络框架。目前该项目已在github上开源，brpc目前被应用于百度公司内部各种核心业务上，其中包括高性能计算和模型训练和各种索引和排序服务，且有超过100万以上个实例是基于brpc工作的。

>  Tars 是将腾讯内部使用的微服务架构 TAF（Total Application Framework）多年的实践成果总结而成的开源项目。 仅支持 C++ 语言，目前在腾讯内部应用也非常广泛。  https://tars.tencent.com/base/tars_index/cn/index.html 

其中关于brpc在知乎有个很好的问题，其中有包括大神戈君(brpc主导者)在内的多个回答，可以帮助我们快速了解brpc框架：[如何评价百度开源的 RPC 框架 brpc？](https://www.zhihu.com/question/65370268)

**tars和brpc是非常不错的开源项目，尤其作为C++程序员很推荐阅读。后面一定要写一下gRPC、brpc、tars，先占个坑。**

#### [zookeeper和dubbo的关系](https://segmentfault.com/a/1190000016349824)

 Dubbo的将注册中心进行抽象，是得它可以外接不同的存储媒介给注册中心提供服务，有ZooKeeper，Memcached，Redis等。  在 Dubbo 官方推荐使用 Zookeeper 就担任了注册中心这一角色。

 ![preview](https://segmentfault.com/img/remote/1460000016349828/view) 

#### [cgi](https://blog.csdn.net/qq_28081081/article/details/80631812)  common gateway interface 通用网关接口

#### [密码加盐]( https://www.zhihu.com/question/20299384 )

> 只对密码进行 md5 加密是肯定不够的。聪明的程序员想出了个办法，即使用户的密码很短，只要我在他的短密码后面加上一段很长的字符，再计算 md5 ，那反推出原始密码就变得非常困难了。加上的这段长字符，我们称为盐（Salt），通过这种方式加密的结果，我们称为 加盐 Hash 。比如：md5(md5(passwd)+salt)

#### [cgi](https://blog.csdn.net/qq_28081081/article/details/80631812)  common gateway interface 通用网关接口

#### [yaml与xml](https://www.cnblogs.com/songchaoke/p/3376323.html)

**优势：**

YAML的可读性好。

YAML和脚本语言的交互性好。

YAML使用实现语言的数据类型。

YAML有一个一致的信息模型。

YAML易于实现。

上面5条也就是XML不足的地方。同时，YAML也有XML的下列优点：

YAML可以基于流来处理；

YAML表达能力强，扩展性好。

总之，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。

更多的内容及规范参见http://www.yaml.org。

#### [协程](https://www.zhihu.com/question/365982400/answer/971777347)

>  常见的协程有Python语言在generator中的yield，Golang语言的goroutine。 

#### PV and QPS

- [PV and QPS](https://www.cnblogs.com/cjsblog/p/9373694.html)

  **PV（Page View）**：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次

  **QPS（Query Per Second）**：每秒请求数，QPS其实是衡量吞吐量的一个常用指标，就是说服务器在一秒的时间内处理了多少个请求。

  **并发数**：并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。

  **峰值QPS**：

  - 原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
  - 公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)

  **UV（Unique Visitor）**：独立访客，统计1天内访问某站点的用户数(以cookie为依据)

  **TPS**（Transactions Per Second）：每秒事务数

  ## TPS

  Transactions Per Second 的缩写，每秒处理的事务数目。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息作出的评估分。

  TPS 的过程包括：客户端请求服务端、服务端内部处理、服务端返回客户端。

  例如，访问一个 Index 页面会请求服务器 3 次，包括一次 html，一次 css，一次 js，那么访问这一个页面就会产生一个 “T”，产生三个 “Q”
链接：https://zhuanlan.zhihu.com/p/96907508
  
  **吐吞量**：吞吐量是指系统在单位时间内处理请求的数量

  **响应时间（RT）**：响应时间是指系统对请求作出响应的时间，一般取平均响应时间

  QPS（每秒查询数）、TPS（每秒事务数）是吞吐量的常用量化指标，另外还有HPS（每秒HTTP请求数）。
  
  QPS（TPS）、并发数、响应时间它们三者之间的关系是：

  - QPS（TPS）= 并发数 / 平均响应时间
  - 并发数 = QPS * 平均响应时间

  举例：【峰值QPS和机器计算公式】

  原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
  公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
  机器：峰值时间每秒QPS / 单台机器的QPS   = 需要的机器
  
  问：每天300w PV 的在单台机器上，这台机器需要多少QPS？
  答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)
  
  问：如果一台机器的QPS是58，需要几台机器来支持？
  
   答：139 / 58 = 3 

### Git

- [实用Github插件](https://blog.csdn.net/u012702547/article/details/100533763)

- git[提交规范](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)  提交规范[2](https://segmentfault.com/a/1190000017205604)

  > #### 格式：
  >
  > ```
  > type(scope) : subject
  > ```
  >
  > ( 1 ) type（必须） : commit 的类别，只允许使用下面几个标识：
  >
  > - feat : 新功能
  > - fix : 修复bug
  > - docs : 文档改变
  > - style : 代码格式改变
  > - refactor : 某个已有功能重构
  > - perf : 性能优化
  > - test : 增加测试
  > - build : 改变了build工具 如 grunt换成了 npm
  > - revert : 撤销上一次的 commit
  > - chore : 构建过程或辅助工具的变动
  >
  > ( 2 ) scope（可选） : 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。
  >
  > ( 3 ) subject（必须） : commit 的简短描述，不超过50个字符。
  > commitizen 是一个撰写合格 Commit message 的工具，
  > 遵循 Angular 的提交规范。

- git 解决冲突方法1

  1. 用TorGit diff之后修改，完成之后选择resoved

  2. **git add 加 git ci youfile , 注意不能git ci . 全部提交**

  3. 步骤2可以用git ci -i  youfile 代替， -i选项告诉git ci之前自动add 

     git -i / --include参数释义

     Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge.

  4. git push

- [git merge解决冲突](https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git)

  > **Step 1**: Run following commands in your terminal
  >
  > ```
  > git config merge.tool vimdiff
  > git config merge.conflictstyle diff3
  > git config mergetool.prompt false
  > ```
  >
  > This will set vimdiff as the default merge tool.
  >
  > **Step 2**: Run following command in terminal
  >
  > ```
  > git mergetool
  > ```
  >
  > **Step 3**: You will see a vimdiff display in following format
  >
  > ```
  >   ╔═══════╦══════╦════════╗
  >   ║       ║      ║        ║
  >   ║ LOCAL ║ BASE ║ REMOTE ║
  >   ║       ║      ║        ║
  >   ╠═══════╩══════╩════════╣
  >   ║                       ║
  >   ║        MERGED         ║
  >   ║                       ║
  >   ╚═══════════════════════╝
  > ```
  >
  > These 4 views are
  >
  > > LOCAL – this is file from the current branch
  > >
  > > BASE – common ancestor, how file looked before both changes
  > >
  > > REMOTE – file you are merging into your branch
  > >
  > > MERGED – merge result, this is what gets saved in the repo
  >
  > You can navigate among these views using ctrl+w. You can directly reach MERGED view using ctrl+w followed by j.
  >
  > More info about vimdiff navigation [here](https://stackoverflow.com/questions/4556184/vim-move-window-left-right) and [here](https://stackoverflow.com/questions/27151456/how-do-i-jump-to-the-next-prev-diff-in-git-difftool)
  >
  > **Step 4**. You could edit the MERGED view the following way
  >
  > If you want to get changes from REMOTE
  >
  > ```
  > :diffg RE  
  > ```
  >
  > If you want to get changes from BASE
  >
  > ```
  > :diffg BA  
  > ```
  >
  > If you want to get changes from LOCAL
  >
  > ```
  > :diffg LO 
  > ```
  >
  > **Step 5**. Save, Exit, Commit and Clean up
  >
  > `:wqa` save and exit from vi
  >
  > ```
  > git commit -m "message"
  > ```
  >
  > `git clean` Remove extra files (e.g. *.orig) created by diff tool.

- # fatal: Authentication failed for

  > git config --system --unset credential.helper //忘掉密码出弹窗
  > git config credential.helper store  //记住密码
  
  
  
  

### [电子书资源下](https://www.jqhtml.com/)

### [中文RFC协议大全](http://www.kaiyuanba.cn/content/develop/rfc/default.htm)

### RPC vs RESTfull

那么我们先看看题目中的问题，其实，这个问题本身就是有问题的！

01. 既然有 HTTP ，为什么还要用 RPC ？

HTTP 和 RPC 并不是两个并行的概念，虽然很多书或文章，都介绍 HTTP 和 RPC 是在“应用层”，但实际上可以把应用层细分成多层，RPC 的所处的位置是高于 HTTP 的；HTTP 是网络协议，而RPC 可以看做是一种编程模式或实现方案；

RPC 通常包含传输协议和序列化协议，单说传输协议，RPC 可以建立在 TCP 协议之上（比如 Dubbo），也可以建立在 HTTP 协议之上（比如 gRPC）；如果是基于数据形式分类，RPC 又可以分成基于二进制、XML 和 JSON 三种；

而现在非常流行的开源 RPC 框架，比如上文中提到的Dubbo 和 gRPC 分别出身于阿里和谷歌，它们更多地是封装了服务注册发现、负载均衡、链路跟踪等功能，也可以这么理解，RPC 框架是对服务更高级的封装。

![img](http://p3.pstatp.com/large/tos-cn-i-0022/4dd0d19af5644bb1aea1dc42e8210ab4)

02. RPC VS Restful 风格的 API

如果非要比较的话，可以比较 RPC 和 Restful 风格的 API。

- **RPC：**面向过程，也就是要做一件什么事情，只发送 GET 和 POST 请求；GET 用来查询信息，其他情况下一律用 POST；请求参数是动词。
- **RESTful：**面向资源，这里的资源可以是一段文字、一个文件、一张图片，总之是一个具体的存在，可以使用 GET、POST、DELETE、PUT 请求，对应了增删查改的操作；请求参数是名词。

比如按照id 查找用户：

- 如果是 RPC 风格的 url 应该是这样的：GET /queryUser?userid=xxx；
- 而 RESTful 风格通常是这样的：GET /user/{userid}

![img](http://p1.pstatp.com/large/2e950000375afffe9a823)

03. 究竟选择哪一个？

RPC 特别适用于是分布式环境；它让客户端进行远程调用时，可以像调用本地方法一样方便；RPC 框架屏蔽了很多底层的细节，开发人员不需要关注这些细节，比如序列化和反序列化、网络传输协议；一些功能强大的 RPC 框架还提供了连接池管理、负载均衡、故障转移、超时管理、上下文管理器、异步回调、收发包队列、工作线程等功能。



**RPC 和 Restful 风格的 API，如果非要争出来个第一第二，那么也要结合具体的使用场景，选择更适合的那个。**

如果是偏向内部的 API，提供的 API 很难进行资源的抽象，没有规范的 API 的设计，性能要求更高，这些情况下更适合使用 RPC ；如果偏向外部 API，需要有更为规范的 API 设计，并且 API 天生是以资源为维度展开的，这时候可以选择 Restful 风格的 API。

![img](http://p3.pstatp.com/large/tos-cn-i-0022/f09510e4b0c44a119fef7cd1937303e3)

### HTTP

[中文HTTP RFC](http://www.kaiyuanba.cn/content/develop/rfc/RFC1945.htm)

[关于HTTP协议，一篇就够了](https://www.jianshu.com/p/80e25cb1d81a)

请求 **格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。**

![img](https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png)

**响应**也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。**空行是必须的即使没有响应正文**

![img](https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg)

**connection**头：若connection 模式为close，则服务器主动关闭[TCP连接](https://www.jianshu.com/p/ef892323e68f)，客户端被动关闭连接，释放[TCP连接](https://www.jianshu.com/p/ef892323e68f); 若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

#### URL

URI rfc3986

举例URL: `https://link.jianshu.com?t=http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name`

从上面的URL可以看出，一个完整的URL包括以下几部分：
 1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2.域名部分：该URL的域名部分为“[www.aspxfans.com](https://link.jianshu.com?t=http://www.aspxfans.com)”。一个URL中，也可以使用IP地址作为域名使用

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。**如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。**

**GET和POST的区别**   

1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.
2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.

**安全性：**GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。POST更加安全

[Http菜鸟教程](https://www.runoob.com/http/http-methods.html)  

#### RESTfull  

说到API接口设计有的喜欢用Web Service，有的喜欢用WCF，当然也有还在用最原始的ashx，aspx页面的。无论采用什么方式能很好的满足业务需求就ok，但是不同的方式在扩展性、易用性，可维护性都有一定的差别。如今移动移动互联网正如火如荼，各种终端，各种平台，各种开发语言也是层出不穷，所以要设计出能满足这些要求的API也就显得至关重要了。

一个文件操作接口，传统模式：

api/getfile.php - 获取文件信息，下载文件
api/uploadfile.php - 上传创建文件
api/deletefile.php - 删除文件

RESTful：

api/file 只需要这一个接口

GET 方式请求 api/file - 获取文件信息，下载文件
POST 方式请求 api/file - 上传创建文件
DELETE 方式请求 api/file - 删除某个文件
原文链接：https://blog.csdn.net/caijunfen/article/details/78413746

 **Representational State Transfer**   表述性状态转移 

 `rest`是一种软件架构风格，如果你们的接口是`rest`接口，那么就可被认为你们的的接口是restful的，英文名词和形容词的区别。  

 `rest`接口是围绕“资源”展开的，利用HTTP的协议，其实rest本也可以和HTTP无关，但是现在大家普遍的使用`rest`都是依托于HTTP协议。HTTP 的url即资源。 

 **对于rest资源的定义，即URL的定义**

Method

- GET：查询资源
- POST：创建资源
- PUT/PATCH
  - PUT：全量更新资源（提供改变后的完整资源）
  - PATCH：局部更新资源（仅提供改变的属性）
- DELETE：删除资源

安全性与幂等性

- 安全性：任意多次对同一资源操作，都不会导致资源的状态变化
- 幂等性：任意次对同一资源操作，对资源的改变是一样的 |Method|安全性|幂等性| |------|:---:|:---:| |GET|√|√| |POST|×|×| |PUT|×|√| |PATCH|×|√| |DELETE|×|√|

 http://www.ruanyifeng.com/blog/2011/09/restful.html 

规范详细版本 https://i6448038.github.io/2017/06/28/rest-%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/](https://i6448038.github.io/2017/06/28/rest-接口规范/

规范v1.0  https://imweb.io/topic/5707561f06f2400432c139a5 

《微服务设计中文版》

REST本身并没有提到底层应该使用什么协议，尽管事实上最常用HTTP。我以前也见
过使用其他协议来实现REST的例子，比如串口或者USB,当然这会引入大量的工作。
HTTP的一些特性，比如动词，使得在HTTP之上实现REST要简单得多，而如果使用其
他协议的话，就需要自己实现这些特性。

REST的约束条件有： https://juejin.im/post/5b92475a5188255c5644819a  那些年，我们一起误解过的REST

1. 统一接口
2. 无状态
3. 缓存
4. 客户端-服务器
5. 分层系统
6. 按需代码（可选）

#### [REST有状态与无状态的理解](https://www.cnblogs.com/hubavyn/p/4759688.html)

 REST（REpresentation State Transfer）表述性状态传递，是一种软件架构风格，是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。**REST 指的是一组架构约束条件和原则。**满足这些约束条件和原则的应用程序或设计就是 RESTful。Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是**无状态**的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。 

 无状态指的是**任意一个Web请求必须完全与其他请求隔离**，当请求端提出请求时，请求本身包含了相应端为相应这一请求所需的全部信息。这一约束的出现改善了分布式系统的可见性、可靠性以及可伸缩性。

  有状态和无状态与请求本身没有多大关联，重要的是**状态信息是由请求方还是响应方负责保存**。

3. 举例说明有状态和无状态：

  客户端向服务器端传递一个session ID是违背REST架构风格的（要求无状态），也就是说这个操作时有状态的，Session ID可以被认为是一个用来标识某一会话状态的Key，将其传递给服务器端意味着这样一个请求：“请帮我取出这个状态信息”，也就是说这个请求假设响应方保有着状态信息。由于与某一特定请求相关的状态属于应用状态，而RESTful架构要求任何此类状态由请求方负责提供，所以传递Session ID被认为是unRESTful的做法。

  客户端向服务器端传递一个user credential作为一种应用状态，是被期望由请求方提供的，所以在请求中传递user credentials（姑且忽略安全性问题）是符合RESTful架构规范的，也就是说是无状态的。

#### [RPC和RESTful API入门篇](https://juejin.im/post/5c19f94fe51d45069e53c03c)

#### [session和token](https://segmentfault.com/a/1190000017831088)

**session时有状态的**，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。

**token是无状态的**，token字符串里就保存了所有的用户信息

- session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie
- cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。
- token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。
- jwt只是一个跨域认证的方案

#### 

### 架构

 **过载保护、接口限流、服务降级、服务熔断、服务隔离、服务解耦、请求队列、削峰填谷、多线程异步化、接口幂等** 

 对于瞬间高并发
（1）服务方面，如果并发太大，你无法准确预估，也不能无限的加机器，那么你必须对你的服务做好过载保护，比如：
接口限流（单接口限流和总流量限流），
服务降级（比如当某个接口响应时间超过阈值，立即返回，不再继续占用资源），
服务熔断（比如某个非核心服务，商品详情页，在系统并发量超过阈值的时候，商品详情服务直接下线）、
服务隔离（比如下单、支付服务一定是和商品详情分开的，下单、支付才是核心，必须确保） 

什么是服务治理？微服务

### 分布式

#### 幂等性 

定义：幂等操作 （Idempotence ）就是多次重复执行与单次执行效果相同。

什么是分布式系统中的幂等性  https://blog.csdn.net/rickiyeat/article/details/71081968 

### serverless

 https://juejin.im/post/5d42945ff265da03a715b2f0  Serverless（无服务）基础知识

IT是一个永远都不消停的行业，在这个行业里不断有各种各样新的名词和技术诞生，云计算（Cloud Computing）的出现是21世纪IT业界最重大的一次变革。云计算的发展从基础架构即服务（Infrastructure as a Service， IaaS），平台即服务（Platform as a Service，PaaS），软件即服务（Software as a Service，SaaS），慢慢开始演变到函数即服务（Function as a Service，FaaS）以及后台即服务（Backend as a Service，BaaS），Serverless 无服务化。

![云计算演变](https://user-gold-cdn.xitu.io/2019/8/1/16c4c1391aeda830?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

目前业界的各类 Serverless 实现按功能而言，主要为应用服务提供了两个方面的支持：函数即服务（Function as a Service，FaaS）以及后台即服务（Backend as a Service，BaaS）。

![serverless结构](https://user-gold-cdn.xitu.io/2019/8/1/16c4c1391b0f2e1d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

作者：凹凸实验室链接：https://juejin.im/post/5d42945ff265da03a715b2f0来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



###  **DevOps**（**Dev**elopment和**Op**erations的组合词）

是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 