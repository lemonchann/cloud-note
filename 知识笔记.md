[TOC]
---
### TODO

#### elasticity search

#### docker



### C和C++

- [结构体赋值的4种方法](https://blog.csdn.net/ericbar/article/details/79567108)
- [stl容器比较vector list queue deque](https://www.jb51.net/article/41590.htm)
- [stl容器比较2](https://blog.csdn.net/a731062834/article/details/82975776)
- [c++继承层次的hide和override](https://www.cnblogs.com/xinxue/p/5471708.html)
- 宏高级用法 #和##和__VA_ARGS__和##__VA_ARGS__
> [ref1](https://blog.csdn.net/u011068702/article/details/93364615)  [ref2](https://blog.csdn.net/blackbillow/article/details/3850587)
> #把宏参数变为一个字符串,用##把两个宏参数贴合在一起. 这里的__VA_ARGS__，是指打印宏里面的可变参数，也就是函数参数里面的...  ##__VA_ARGS__ 可变参数只有一个也能传递
- 前置声明的真正用法：
1. 在头文件里不引入过多的其他头文件和名称空间，避免污染
2. 在相应的c文件里面再引入其他头文件
3. 同时，必须把头文件放在需要引用的其他头文件之后才行
4. 因为，编译都是从c文件开始，头文件只是包含展开而已。
- 隐藏与重写
>- hide隐藏作用于子类和基类都有同一个非虚函数的继承，子类的函数会把基类的隐藏掉;
> - override重写作用于非纯虚函数的继承层次，子类重写基类的虚函数实现。

---
### python

- [pycharm常用快捷键](https://www.cnblogs.com/insane-Mr-Li/p/9698994.html)

- [为什么不推荐Selenium写爬虫](https://zhuanlan.zhihu.com/p/33542626)

- [理解Python协程:从yield/send到yield from再到async/await](https://blog.csdn.net/soonfly/article/details/78361819)

- 获取帮助help(str.join)  help(list.) help(dict.) help(tuple.)

- [语法糖](https://blog.csdn.net/wofreeo/article/details/80679290)
[Python语法糖系列](https://blog.csdn.net/five3/article/details/83474633)
- [Python爬虫之requests库(二)：响应内容、响应状态码、响应头](https://blog.csdn.net/bqw18744018044/article/details/81171220)
- [Pybind11调用c++](https://zhuanlan.zhihu.com/p/63290768)
- [Python 入门指南](http://www.pythondoc.com/pythontutorial3/modules.html)
- [官方Python 3.7.3 documentation-在程序安装目录的Doc下](https://docs.python.org/3/)
- [pycharm教程](https://www.cnblogs.com/tsingke/p/7392800.html)
- [pycharm破解方法](https://blog.csdn.net/qq_41235053/article/details/81390453)
- [pycharm破解码生成网站](http://idea.lanyus.com/)

> 56ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==
- [py2中的raw_input，input 与 py3中的input](https://blog.csdn.net/qq_39480314/article/details/80092051)
- 进阶：effective python
- [diveinto python中文版官网](https://woodpecker.org.cn/diveintopython/toc/index.html)
- [生成器VS迭代器1](http://python.jobbole.com/87805/)
- [生成器VS迭代器2](https://www.cnblogs.com/wj-1314/p/8490822.html)
- [notepad++支持markdown](https://www.jianshu.com/p/cdb42773fffe)

- [字符编码方式](https://baike.baidu.com/item/Unicode)
> **Unicode**   
> Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案,Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布  
> **UTF-8**  
> *Unicode Transformation Format*的缩写，可以翻译成Unicode字符集转换格式，即怎样将Unicode定义的数字转换成程序数据
> UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：

| Unicode编码(十六进制) | UTF-8 字节流(二进制)             |
| --------------------- | -------------------------------- |
| 000000-00007F         | 0xxxxxxx                         |
| 000080-0007FF         | 110xxxxx 10xxxxxx                |
| 000800-00FFFF         | 1110xxxx 10xxxxxx 10xxxxxx       |
| 010000-10FFFF         | 11110xxx10xxxxxx10xxxxxx10xxxxxx |

>UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。
>例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。
>例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。

- 数据库读取  records库

---
### C++11
- g++ -std=c++11 编译选项
- [C++11常用特性快速一览](https://blog.csdn.net/jiange_zh/article/details/79356417)
- [C和C++中的左值和右值](https://blog.csdn.net/xuwqiang1994/article/details/79924310)
- [30分钟了解C++11新特性](https://www.cnblogs.com/mengfanrong/p/5230558.html)
- [GCC4.8 支持C++11](https://www.cnblogs.com/jhj117/p/6117204.html)
---
### shell
- [shell获取字符串长度](https://www.jb51.net/article/121290.htm)
- [Shell $?：获取函数返回值或者上一个命令的退出状态](http://c.biancheng.net/view/808.html)
> 1. 命令的退出状态0-正常；非0-不正常
> 2. 获取函数的返回值
---
### 虚拟机
- [centos桌面版安装](https://blog.csdn.net/alan_gaohaodong/article/details/79867052)
- [Virtualbox扩展虚拟磁盘空间大小](https://blog.csdn.net/tanningzhong/article/details/80482994)

---
### Linux
- [认真分析mmap：是什么 为什么 怎么用](https://www.cnblogs.com/huxiao-tee/p/4660352.html) 

- [win查看MD5 SHA](https://blog.csdn.net/p358278505/article/details/70672169)

- makefile语法学习

- 时间转换命令

  ```
  [root@365linux ~]# date +%s 
  [root@365linux ~]# date -d "@1279592730" 
  [root@365linux ~]# date -d '06/12/2018 07:21:22' +"%s"
  1528759282
  [root@365linux ~]# date -d '2018-06-12 07:21:22' +"%s"
  1528759282
  ```
  
- linux[时间函数](https://juejin.im/post/5be682706fb9a049ef261855)

   编译时要在编译命令最后加上-lrt链接Real Time动态库，如 g++ -o time2 test_time_linux_2.cpp -lrt 

- linux data[命令获取上一天时间](https://blog.csdn.net/classhao1/article/details/8182733)

   获取明天的日期

   date -d next-day +%Y%m%d

   获取昨天的日期

   date -d last-day +%Y%m%d

   获取上个月的年和月

   date -d last-month +%Y%m

   获取下个月的年和月
   date -d next-month +%Y%m

   获取明年的年份
   date -d next-year +%Y

- [crontab在线测试](https://tool.lu/crontab)

- 非常好用的Linux调试命令

   [strace](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html)

    strace常用来跟踪进程执行时的系统调用和所接收的信号。还可以统计时间开销

     [pstack](https://www.cnblogs.com/kongzhongqijing/articles/7685699.html) 

    `pstack`是一个shell脚本，用于打印正在运行的进程的栈跟踪信息，它实际上是`gstack`的一个链接，而gstack本身是   基于gdb封装的shell脚本.。  `pstack`是gdb的一部分 

   

---
### 算法
- [斐波那契实现C版本](https://blog.csdn.net/weixin_40740059/article/details/80012909)

- [快速求幂算法](https://blog.csdn.net/hkdgjqr/article/details/5381028)

- [牛客题目](https://www.nowcoder.com/questionTerminal/1a834e5e3e1a4b7ba251417554e07c00)

- [base64](https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576)

  > Base64是一种用64个字符来表示任意二进制数据的方法。Base64的原理很简单，首先，准备一个包含64个字符的数组：
  >
  > ```
  > ['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']
  > ```
  >
  > 然后，对二进制数据进行处理，每3个字节一组，一共是`3x8=24`bit，划为4组，每组正好6个bit：
  >
  > ![base64-encode](https://www.liaoxuefeng.com/files/attachments/949444125467040)
  >
  > 这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。
---
### 工具生产力
- [vscode插件推荐](https://blog.fundebug.com/2018/07/24/vs-extensions/)
- [notepad++显示文件列表](https://jingyan.baidu.com/article/066074d61011f3c3c21cb0ce.html)
- [正则表达式\w \d](https://www.jb51.net/article/118706.htm)
- 正则常见匹配
> * . 匹配除换行符以外的任意字符  
> * \w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。   
> * \s 匹配任意的空白符
> * \d 匹配数字
> * \b 匹配单词的开始或结束
> * ^ 匹配字符串的开始
> * $ 匹配字符串的结束
> * \w能不能匹配汉字要视你的操作系统和你的应用环境而定

- [CI/CD]https://www.redhat.com/zh/topics/devops/what-is-ci-cd
> CI/CD 中的“CI”始终指持续集成, CD 持续交付和/或持续部署
- [Win10操作](https://www.zhihu.com/question/54389145/answer/143788533)   
> win+q是打开Cortana的搜索框，可以搜索应用，比如记事本，可以搜索可执行程序，比如能够在“运行“中直接使用的，如calc计算器，notepad记事本，mspaint画图，cmd是命令行  
win+x   
win+上下左右，可以调整窗口，最大化/还原，靠左/靠右贴边排列。     ctrl+win+d创建新的虚拟桌面，ctrl+win+左右用来切换桌面，ctrl+win+F4关闭虚拟桌面（win+tab的任务视图里也可以管理虚拟桌面）。
ctrl+shift+esc启动任务管理器，比ctrl+alt+delete少一步操作。
截图不需要qq。键盘上的PrtScn按键就是截图键，全屏截图到剪贴板，在绝大部分操作系统和软件下都通用。alt+PrtScn是当前窗口截图。

- [Typora md编辑器](https://sspai.com/post/54912)

- [Typora写微信公众号](https://sspai.com/post/40524)

- [Typora换公众号主题](http://support.typora.io/About-Themes/)

- [代码在线运行工具](https://tool.lu/coderunner/)

- 宇宙IDE vs2017

  [快捷键](https://www.cnblogs.com/lsgxeva/p/7944986.html)

  > F12  跳到定义; Ctrl+F12跳到声明；ctrl+-向前导航; ctrl+shift+-向后导航

  Visual Studio添加整个目录到空项目中 https://blog.csdn.net/oneinmore/article/details/43017471

  visual studio 工程目录,添加文件夹 和添加筛选器 的 https://bbs.csdn.net/topics/390838516

  visual studio技巧总结 https://blog.csdn.net/wu_nan_nan/article/details/70159267

  去掉讨厌的红色下划波浪线（ 拼写检查）https://blog.csdn.net/qq_33075489/article/details/79783142

  VS2017环境下开发Linux程序 https://blog.csdn.net/CSDN_WHB/article/details/85223652

  IDE跨平台路径： C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\Common7\IDE\VC\Linux\include\usr\local\include\google\protobuf

  添加文件类型：工具-》选项-》VC++项目设置-》要包括的扩展名

  项目属性-》常规-》配置类型-》动态库so

  一个改动，win下编译工程只会同步改动的文件过去

  跨平台编译要触发重新上传代码，一定要点重新生成。命令行的位置是生成事件-》远程链接之前事件
  
- [source insight 自动注释插件](https://my.oschina.net/u/2515635/blog/717976)

- csv  **Comma-Separated Values**

  > csv是最通用的一种文件格式，它可以非常容易地被导入各种PC表格及数据库中。 此文件，一行即为数据表的一行。生成数据表字段用半角逗号隔开。csv文件用记事本和excel都能打开，用记事本打开显示逗号，用excel打开，没有逗号了，逗号都用来分列了.

---
### Protocol buff
[protol buf](https://blog.csdn.net/GG_SiMiDa/article/details/81506024)
[PB中文翻译](https://colobu.com/2015/01/07/Protobuf-language-guide/#%E6%8C%87%E5%AE%9A%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B)
[官方指南](https://developers.google.com/protocol-buffers/docs/proto3)   
[protol buff1](https://blog.csdn.net/weixin_33686714/article/details/93640860)   
[protobuf详细](https://www.cnblogs.com/langqi250/p/7283702.html)
[protobuf extension1](https://www.cnblogs.com/mydomain/p/3177087.html)  [protobuf extension2](https://zhuanlan.zhihu.com/p/53059833)

>  extend字段是用来对原有的message类型进行扩展的。在某些场景下，可能在定义了一个基础的消息类型之后，不同的使用方需要在这个基础的消息类型上添加自己的独有字段。又或者在后续的功能升级过程中需要对该消息类型增加新的字段。这个时候预先定义了extend字段的话，就可以直接对消息进行扩展，而不用修改原来的proto文件修改消息类型的定义了。
> 一个典型的使用场景如统一的数据管理平台，不同的使用方上传的数据使用的字段是不一样的，由平台方把所有可能使用到的字段写到同一份proto文件中显然是不可能的。如记录商品信息的数据需要的字段可能是商品名、商品价格、生产日期等，而记录职员信息的数据需要的字段是姓名、年龄、职位、工龄等。此时，平台接口定义的消息类型可以只包含诸如时间、使用者等统一字段，同时预留出足够的extend字段由使用者自行定义。 

---
### 数据库

#### sql

-  [select distinct 多列]( https://blog.csdn.net/bitcarmanlee/article/details/51100279 ) 

  > 2.distinct多列
  > select distinct a,b,c from tableA;
  > 注意此时是将a,b,c三列所有不同的组合全部列出来，而不仅仅只是distinct a
  > 相当于以下语句：
  >
  >  select a,b,c from tableA group by a,b,c

- mysql count及其他语法学习语法  

-  《高性能MySQL》 推荐书！！！

- MySql[官方文档](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)

- [leveldb](https://juejin.im/post/5c22e049e51d45206d12568e)

- 分库分表数据库 [分库分表](https://juejin.im/entry/5b5eb7f2e51d4519700f7d3c)

- [各类分区](https://www.cnblogs.com/chenmh/p/5627912.html)详解

- Mysql[分表方法](http://blog.51yip.com/mysql/949.html)

  > INSERT INTO user1(user1.id,user1.name,user1.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id <= 250000
  >
  > INSERT INTO user2(user2.id,user2.name,user2.sex)SELECT (user.id,user.name,user.sex)FROM user where user.id > 250000
  
  - [Mysql分区分表数](https://blog.csdn.net/afsvsv/article/details/84998119)
  
  > **分区的类型：**
  >
  > - RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区
  > - LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择
  > - HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式
  > - KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
  > - 具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。
  
  > **分区的限制和缺点：**
  >
  > - 一个表最多只能有1024个分区
  > - 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
  > - 分区表无法使用外键约束
  > - NULL值会使分区过滤无效
  > - 所有分区必须使用相同的存储引擎
  
  - [对已有数据的mysql表进行分区](https://blog.csdn.net/changcongying/article/details/79497004)
  
  - [查看表是否分区](https://blog.csdn.net/xiaoborui20110806/article/details/38313821)  [查看表是否有索引](https://www.cnblogs.com/tianhuilove/archive/2011/09/05/2167795.html) [查看容量](https://www.cnblogs.com/dekevin/p/10276832.html)
  
    > mysql> show global variables like 'port'; 查看端口
    >
    > mysql> select version(); 查看版本
  
  - [MYSQL(分表)千万级数据量的优化方法积累](https://blog.csdn.net/zhaoliang831214/article/details/52790063)
  
  > 先创建与旧表相同结构的临时表：
  >
  > CREATE TABLE members_tmp LIKE members
  >
  > 对于mysql的复制相同表结构方法，有create table as 和create table like 两种，二者的用途：
  >
  >   as用来创建相同表结构并复制源表数据
  >
  >   like用来创建完整表结构和全部索引
  >
  > 接着重命名将新表替换上去：
  >
  > RENAME TABLE members TO members_bak,members_tmp TO members;
  >
  > 旧表( `old_table_name`)必须存在，而新表( `new_table_name`)一定不存在。如果新表 `new_table_name `确实存在，该语句将失败。 
  
- [数据库索引](https://blog.csdn.net/justry_deng/article/details/81458470) [索引2](https://www.w3school.com.cn/sql/sql_create.asp) [索引3](https://blog.csdn.net/cxfjava/article/details/84869570) [主键和索引](https://blog.csdn.net/heshushun/article/details/79773957)

  > **建表后加索引：**
  >
  > ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL]  INDEX | KEY  [索引名] (字段名1 [(长度)] [ASC | DESC]) [USING 索引方法]；或
  >
  > CREATE  [UNIQUE | FULLTEXT | SPATIAL]  INDEX  索引名 ON  表名(字段名) [USING 索引方法]；
  
  > 1）主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；
  > 2）主键不允许为空值，唯一索引列允许空值；
  >
  > 3）一个表只能有一个主键，但是可以有多个唯一索引；
  > 4）主键可以被其他表引用为外键，唯一索引列不可以；
  > 5）主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本质的差别
  
- [数据库迁移](https://www.cnblogs.com/SZxiaochun/p/8359456.html)  [数据库迁移2](https://blog.csdn.net/yumushui/article/details/41647997)

  > mysqldump -u root -p123456 --all-databases > all.sql
  >
  > mysql -u root -p123456 < "D:\MySQL 5.5\bin\all.sql"

  > 对于MySQL中数据库容量比较大，而且变化比较大的数据库，采用 xtrabackup 备份后恢复构建 master-slave 的方式，然后关闭主库，启用从库的迁移保教保险和使用；
  > 但对于容量比较小，业务和变化量也比较少的mysql数据库，和Oracle数据库的export/import类型，采用mysqldump导入和导出的方式比较快捷和高效。

  [mysql bin log]( https://www.cnblogs.com/martinzhang/p/3454358.html )  [binlog详细](https://zhuanlan.zhihu.com/p/33504555)

  > ```
  > 一、开启binlog日志：
  >     vi编辑打开mysql配置文件
  >     # vi /usr/local/mysql/etc/my.cnf
  >     在[mysqld] 区块
  >     设置/添加 log-bin=mysql-bin  确认是打开状态(值 mysql-bin 是日志的基本名或前缀名)；
  > 
  >     重启mysqld服务使配置生效
  >     # pkill mysqld
  >     # /usr/local/mysql/bin/mysqld_safe --user=mysql &
  > 
  > 
  > 二、也可登录mysql服务器，通过mysql的变量配置表，查看二进制日志是否已开启 单词：variable[ˈvɛriəbəl] 变量
  > 
  >     登录服务器
  >     # /usr/local/mysql/bin/mysql -uroot -p123456
  > 
  >     mysql> show variables like 'log_%'; 
  > ```
  
  > ```
  > log-bin=mysql-bin
  > ```
  >
  > binlog 就是binary log，二进制日志文件，这个文件记录了mysql所有的dml操作。通过binlog日志我们可以做数据恢复，做主住复制和主从复制等等
  
- [Mysql分区和索引查找顺序](https://www.zhihu.com/question/21738216)

  > 在《高性能Mysql》这本书的‘如何使用分区’这一小章中，列举的常见问题中，有以下一个问题：
  >
  > **分区列和索引列不匹配**
  > 如果定义的索引列和分区列不匹配，会导致查询无法进行分区过滤。假设在列a上定义了索引，而在列b上定义的分区。因为每个分区都有其独立的索引，所以扫描列b上的索引就需要扫描每个分区内对应的索引。要避免这个问题，应该避免建立和分区列不匹配的索引，**除非查询中还同时包含了可以过滤分区的条件。**
  >
  > **where 条件中带了 A 的话，那么即是带了分区条件，这时候是会去到对应的分区，再利用 B 的索引进行查找。**
  
- [复合索引的建立以及最左前缀原则](https://blog.csdn.net/zmx729618/article/details/52701532)

  >  假设你在表的state、city和zip数据列上建立了复合索引。索引中的数据行按照state/city/zip次序排列，因此它们也会自动地按照state/city和state次序排列。这意味着，即使你在查询中只指定了state值，或者指定state和city值，MySQL也可以使用这个索引。因此，这个索引可以被用于搜索如下所示的数据列组合：
  >     state, city, zip
  >     state, city
  >     state 

- [MySQL中interactive_timeout和wait_timeout的区别](https://www.cnblogs.com/ivictor/p/5979731.html)

- Mysql[查看支持的字符集](https://www.cnblogs.com/chyingp/p/mysql-character-set-collation.html)

- Mysql 中int(11)[含义](https://cloud.tencent.com/developer/ask/36535)

  概括地说：int(N)中括号中的数字是最大的宽度，就像varchar(N)一样。

  但Integer数据类型的情况并非如此

  **括号中的数字N不是列的最大大小，而是一个参数，用于显示列的宽度**

  括号中的数字将告诉MySQL需要使用多少个零来填充传入整数。例如：如果在设置为int(5)并插入数字78的列上使用ZEROFILL参数，MySQL将使用零填充该值，直到该数字满足括号中的数字为止。也就是说，78将变成00078，127将变成00127。总之：括号中的数字用于显示。

  有些情况下，除非使用ZEROFILL属性，否则括号中的数字是没有用的。

  所以int的大小将保持不变，也就是说，**-2147483648至2147483648有符号**和**0至4294967295无符号**，就字节而言，它就是**4字节**...

- explain[查看分区](http://www.voidcn.com/article/p-ytvkfudz-eo.html)

  ```sql
  mysql> explain partitions select * from ClientActionTrack where startTime>'2016-08-25 00:00:00' and startTime<'2016-08-25 23:59:00';
  +----+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+
  | id | select_type | table             | partitions | type | possible_keys | key  | key_len | ref  | rows  | Extra       |
  +----+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+
  |  1 | SIMPLE      | ClientActionTrack | p20160825  | ALL  | NULL          | NULL | NULL    | NULL | 33868 | Using where |
  +----+-------------+-------------------+------------+------+---------------+------+---------+------+-------+-------------+
  1 row in set (0.00 sec)
  ```

- [查看容量](https://blog.csdn.net/fdipzone/article/details/80144166)

  select 
  table_schema as '数据库',
  table_name as '表名',
  table_rows as '记录数',
  truncate(data_length/1024/1024, 2) as '数据容量(MB)',
  truncate(index_length/1024/1024, 2) as '索引容量(MB)'
  from information_schema.tables
  where table_schema='APV4_MAIN'
  order by data_length desc, index_length desc;

---
### 后台开发
- [cgi](https://blog.csdn.net/qq_28081081/article/details/80631812)  common gateway interface 通用网关接口

- [密码加盐]( https://www.zhihu.com/question/20299384 )

  > 只对密码进行 md5 加密是肯定不够的。聪明的程序员想出了个办法，即使用户的密码很短，只要我在他的短密码后面加上一段很长的字符，再计算 md5 ，那反推出原始密码就变得非常困难了。加上的这段长字符，我们称为盐（Salt），通过这种方式加密的结果，我们称为 加盐 Hash 。比如：md5(md5(passwd)+salt)

- [cgi](https://blog.csdn.net/qq_28081081/article/details/80631812)  common gateway interface 通用网关接口

- [yaml与xml](https://www.cnblogs.com/songchaoke/p/3376323.html)

  **优势：**

  YAML的可读性好。

  YAML和脚本语言的交互性好。

  YAML使用实现语言的数据类型。

  YAML有一个一致的信息模型。

  YAML易于实现。

  上面5条也就是XML不足的地方。同时，YAML也有XML的下列优点：

  YAML可以基于流来处理；

  YAML表达能力强，扩展性好。

  总之，YAML试图用一种比XML更敏捷的方式，来完成XML所完成的任务。

  更多的内容及规范参见http://www.yaml.org。

- [协程](https://www.zhihu.com/question/365982400/answer/971777347)

  >  常见的协程有Python语言在generator中的yield，Golang语言的goroutine。 

### Git

- [实用Github插件](https://blog.csdn.net/u012702547/article/details/100533763)

- git[提交规范](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)  提交规范[2](https://segmentfault.com/a/1190000017205604)

  > #### 格式：
  >
  > ```
  > type(scope) : subject
  > ```
  >
  > ( 1 ) type（必须） : commit 的类别，只允许使用下面几个标识：
  >
  > - feat : 新功能
  > - fix : 修复bug
  > - docs : 文档改变
  > - style : 代码格式改变
  > - refactor : 某个已有功能重构
  > - perf : 性能优化
  > - test : 增加测试
  > - build : 改变了build工具 如 grunt换成了 npm
  > - revert : 撤销上一次的 commit
  > - chore : 构建过程或辅助工具的变动
  >
  > ( 2 ) scope（可选） : 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。
  >
  > ( 3 ) subject（必须） : commit 的简短描述，不超过50个字符。
  > commitizen 是一个撰写合格 Commit message 的工具，
  > 遵循 Angular 的提交规范。

- [git merge解决冲突](https://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git)

  > **Step 1**: Run following commands in your terminal
  >
  > ```
  > git config merge.tool vimdiff
  > git config merge.conflictstyle diff3
  > git config mergetool.prompt false
  > ```
  >
  > This will set vimdiff as the default merge tool.
  >
  > **Step 2**: Run following command in terminal
  >
  > ```
  > git mergetool
  > ```
  >
  > **Step 3**: You will see a vimdiff display in following format
  >
  > ```
  >   ╔═══════╦══════╦════════╗
  >   ║       ║      ║        ║
  >   ║ LOCAL ║ BASE ║ REMOTE ║
  >   ║       ║      ║        ║
  >   ╠═══════╩══════╩════════╣
  >   ║                       ║
  >   ║        MERGED         ║
  >   ║                       ║
  >   ╚═══════════════════════╝
  > ```
  >
  > These 4 views are
  >
  > > LOCAL – this is file from the current branch
  > >
  > > BASE – common ancestor, how file looked before both changes
  > >
  > > REMOTE – file you are merging into your branch
  > >
  > > MERGED – merge result, this is what gets saved in the repo
  >
  > You can navigate among these views using ctrl+w. You can directly reach MERGED view using ctrl+w followed by j.
  >
  > More info about vimdiff navigation [here](https://stackoverflow.com/questions/4556184/vim-move-window-left-right) and [here](https://stackoverflow.com/questions/27151456/how-do-i-jump-to-the-next-prev-diff-in-git-difftool)
  >
  > **Step 4**. You could edit the MERGED view the following way
  >
  > If you want to get changes from REMOTE
  >
  > ```
  > :diffg RE  
  > ```
  >
  > If you want to get changes from BASE
  >
  > ```
  > :diffg BA  
  > ```
  >
  > If you want to get changes from LOCAL
  >
  > ```
  > :diffg LO 
  > ```
  >
  > **Step 5**. Save, Exit, Commit and Clean up
  >
  > `:wqa` save and exit from vi
  >
  > ```
  > git commit -m "message"
  > ```
  >
  > `git clean` Remove extra files (e.g. *.orig) created by diff tool.

- # fatal: Authentication failed for

  > git config --system --unset credential.helper //忘掉密码出弹窗
  > git config credential.helper store  //记住密码

### [电子书资源下](https://www.jqhtml.com/)

### [中文RFC协议大全](http://www.kaiyuanba.cn/content/develop/rfc/default.htm)

### HTTP

[中文HTTP RFC](http://www.kaiyuanba.cn/content/develop/rfc/RFC1945.htm)

[关于HTTP协议，一篇就够了](https://www.jianshu.com/p/80e25cb1d81a)

请求 **格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。**

![img](https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png)

**响应**也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。**空行是必须的即使没有响应正文**

![img](https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg)

**connection**头：若connection 模式为close，则服务器主动关闭[TCP连接](https://www.jianshu.com/p/ef892323e68f)，客户端被动关闭连接，释放[TCP连接](https://www.jianshu.com/p/ef892323e68f); 若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

举例URL: `https://link.jianshu.com?t=http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name`

从上面的URL可以看出，一个完整的URL包括以下几部分：
 1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2.域名部分：该URL的域名部分为“[www.aspxfans.com](https://link.jianshu.com?t=http://www.aspxfans.com)”。一个URL中，也可以使用IP地址作为域名使用

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。**如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。**

**GET和POST的区别**   

1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.
2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.

**安全性：**GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。POST更加安全

[Http菜鸟教程](https://www.runoob.com/http/http-methods.html)  

